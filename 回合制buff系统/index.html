<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>在unity中的一个比较完善的回合制buff系统框架（暂时已废弃） - Fivuvuv's note</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Fivuvuv's note</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../readme/" class="nav-link">Home</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Unity</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../Unity/%E5%85%B3%E4%BA%8Egithub%E9%A1%B9%E7%9B%AE%E8%94%9A%E8%93%9D%E6%89%8B%E6%84%9F2d%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%A0%94%E7%A9%B6/" class="dropdown-item">关于github项目蔚蓝手感2d控制器的研究</a>
</li>
                                    
<li>
    <a href="../Unity/ai%E7%A0%94%E7%A9%B6%E6%A6%82%E8%BF%B0/" class="dropdown-item">ai研究概述</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="../图形与视觉" class="nav-link">图形与视觉</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">计算机语言</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" class="dropdown-item">Index</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="../数据结构与算法" class="nav-link">数据结构与算法</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">计算机基础</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/default/" class="dropdown-item">Default</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">常用工具使用</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/default/" class="dropdown-item">Default</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">杂项</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../%E6%9D%82%E9%A1%B9/mkdocs%E5%91%BD%E4%BB%A4/" class="dropdown-item">Mkdocs命令</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="../研究生打杂" class="nav-link">研究生打杂</a>
                            </li>
                            <li class="nav-item">
                                <a href="../数学" class="nav-link">数学</a>
                            </li>
                            <li class="nav-item">
                                <a href="../面试" class="nav-link">面试</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../readme/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../Unity/ai%E7%A0%94%E7%A9%B6%E6%A6%82%E8%BF%B0/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/2333qbyqby/new-public-note.git/edit/master/docs/回合制buff系统.md" class="nav-link">Edit on 2333qbyqby/new-public-note
                                    </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#unitybuff" class="nav-link">在unity中的一个比较完善的回合制buff系统框架（暂时已废弃）</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">前言：</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#buff" class="nav-link">原本的buff系统：</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#buff_2" class="nav-link">新buff系统：</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="unitybuff">在unity中的一个比较完善的回合制buff系统框架（暂时已废弃）</h1>
<h2 id="_1">前言：</h2>
<p>​   在前两个月开发的的cusga，笔者仿照猴叔的可扩展俯视角射击<a href="https://zhuanlan.zhihu.com/p/416805924">用Unity制作一个极具扩展性的顶视角射击游戏战斗系统 - 知乎 (zhihu.com)</a></p>
<p>完成了游戏中的buff系统的构建，经过了一些小小的魔改，在配置上和扩展上达到了可以接受的程度，但是还是饱受另一位配置的程序的诟病，于是有了这篇文章，基于之前的框架，进行一些重构，来达到配置更简单，更容易扩展的目的。</p>
<h2 id="buff">原本的buff系统：</h2>
<h3 id="buff_1">原本buff系统组成：</h3>
<p>(本buff系统基本上来自于猴叔的架构，所以看过猴叔的可以简单地跳过)</p>
<h4 id="buffdata">BuffData</h4>
<p>原本的buff系统大体由BuffData,BuffInfo,BuffHandler组成，其中buffData是buff的基础配置，是静态的配置，由一些buff的信息和回调点的delegate以及各个delegate的参数组成（关于回调点的概念，请参考上面的知乎文章，另外，在旧的buff系统中，其实回调点参数都没有使用），buffdata的具体定义如下：</p>
<pre><code class="language-C#">public class BuffData
{

    /// &lt;summary&gt;
    /// buff的唯一id
    /// &lt;/summary&gt;
    public string id;
    /// &lt;summary&gt;
    /// buff的名字
    /// &lt;/summary&gt;
    public string buffName;
    /// &lt;summary&gt;
    /// 存储buff的icon图标的路径，resoueces读取，后面没用上
    /// &lt;/summary&gt;
    public string buffIcon;
    /// &lt;summary&gt;
    /// 用于方便检索的tag，例如：火焰，冰冻，中毒等
    /// &lt;/summary&gt;
    public string[] tags;
    /// &lt;summary&gt;
    /// buff的最高层数
    /// &lt;/summary&gt;
    public int maxStack;
    //当buff的层数发生变化时，buff的更新策略
    public BuffUpdateEnum buffUpdateEnum;

    public BuffRemoveStackUpdateEnum removeStackUpdateEnum;

    //buff的时间信息
    public int duringCount;
    /// &lt;summary&gt;
    /// 是否是永久的buff
    /// &lt;/summary&gt;
    public bool isPermanent;
    /// &lt;summary&gt;
    /// buff会给角色添加的属性，暂定两种，一种加算，一种乘算
    /// &lt;/summary&gt;
    public ChaProperty[] propMod;
    /// &lt;summary&gt;
    /// buff对于角色状态的修改
    /// &lt;/summary&gt;
    public ChaControlState stateMod;
    /// &lt;summary&gt;
    /// buff在创建的时候的事件
    /// &lt;/summary&gt;
    public OnBuffCreate onCreate;
    public object[] onCreateParams;
    /// &lt;summary&gt;
    /// buff在移除的时候的事件
    /// &lt;/summary&gt;
    public OnBuffRemove onRemove;
    public object[] onRemoveParams;
    /// &lt;summary&gt;
    /// 在回合开始的时候的触发的事件
    /// &lt;/summary&gt;
    public OnRoundStart onRoundStart;
    public object[] onRoundStartParams;
    /// &lt;summary&gt;
    /// 在回合结束的时候触发的事件
    /// &lt;/summary&gt;
    public OnRoundEnd onRoundEnd;
    public object[] onRoundEndParams;
    /// &lt;summary&gt;
    /// 在伤害流程中，持有这个buff的角色作为攻击者时触发的事件
    /// &lt;/summary&gt;
    public BuffOnHit onHit;
    public object[] onHitParams;
    /// &lt;summary&gt;
    /// 在伤害流程中，持有这个buff的角色作为被攻击者时触发的事件
    /// &lt;/summary&gt;
    public BuffOnBeHurt onBeHurt;
    public object[] onBeHurtParams;
    /// &lt;summary&gt;
    /// 在开局玩家操作阶段roll骰子时触发的事件
    /// &lt;/summary&gt;
    public BuffOnRoll onRoll;
    public object[] onRollParams;
    /// &lt;summary&gt;
    /// 在伤害流程中，如果击杀目标，会触发的事件
    /// &lt;/summary&gt;
    public BuffOnkill onKill;
    public object[] onKillParams;

    public BuffOnBeKilled onBeKilled;
    public object[] onBeKilledParams;

    public BuffOnCast OnCast;
    public object[] onCastParams;

    public OnAddBuff onAddBuff;
    public object[] onAddBuffParams;

    public OnGetFinalDamage onGetFinalDamage;
    public object[] onGetFinalDamageParams;
    public BuffData(
        string id, string name, string icon, string[] tags, int maxStack, int duringCount, bool isPermanent,
        BuffUpdateEnum buffUpdateEnum, BuffRemoveStackUpdateEnum removeStackUpdateEnum,
        string onCreate, object[] onCreateParams,
        string onRemove, object[] onRemoveParams,
        string onRoundStart, object[] onRoundStartParams,
        string onRoundEnd, object[] onRoundEndParams,
        string onHit, object[] onHitParams,
        string onBeHurt, object[] onBeHurtParams,
        string onRoll, object[] onRollParams,
        string onKill, object[] onKillParams,
        string onBeKilled, object[] onBeKilledParams,
        string onCast, object[] onCastParams,
        string onAddBuff, object[] onAddBuffParams,
        string onGetFinalDamage, object[] onGetFinalDamageParams,
        ChaControlState stateMod, ChaProperty[] propMod = null
        )
    {
        this.id = id;
        this.buffName = name;
        this.buffIcon = icon;
        this.tags = tags;
        this.maxStack = maxStack;
        this.duringCount = duringCount;
        this.isPermanent = isPermanent;
        this.propMod = new ChaProperty[2]
            {ChaProperty.zero,
             ChaProperty.zero
        };

        if (propMod != null)
        {
            for (int i = 0; i &lt; Mathf.Min(propMod.Length, 2); i++)
            {
                this.propMod[i] = propMod[i];
            }
        }
        this.stateMod = stateMod;

        this.onCreate = (onCreate == &quot;&quot; )? null : DesignerScripts.BuffEvents.onCreateFunc[onCreate];
        this.onCreateParams = onCreateParams;
        this.onRemove = (onRemove == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onRemoveFunc[onRemove];
        this.onRemoveParams = onRemoveParams;
        this.onRoundStart = (onRoundStart == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onRoundStartFunc[onRoundStart];
        this.onRoundStartParams = onRoundStartParams;
        this.onRoundEnd = (onRoundEnd == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onRoundEndFunc[onRoundEnd];
        this.onRoundEndParams = onRoundEndParams;
        this.onHit = (onHit == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onBuffHitFunc[onHit];
        this.onHitParams = onHitParams;
        this.onBeHurt = (onBeHurt == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onBeHurtFunc[onBeHurt];
        this.onBeHurtParams = onBeHurtParams;
        this.onRoll = (onRoll == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onRollFunc[onRoll];
        this.onRollParams = onRollParams;
        this.onKill = (onKill == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onKillFunc[onKill];
        this.onKillParams = onKillParams;
        this.onBeKilled = (onBeKilled == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onBeKillFunc[onBeKilled];
        this.onBeKilledParams = onBeKilledParams;
        this.OnCast = (onCast == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onCastFunc[onCast];
        this.onCastParams = onCastParams;
        this.onAddBuff = (onAddBuff == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onAddFunc[onAddBuff];
        this.onAddBuffParams = onAddBuffParams;
        this.onGetFinalDamage = (onGetFinalDamage == &quot;&quot;) ? null : DesignerScripts.BuffEvents.onGetFinalDamageFunc[onGetFinalDamage];
        this.onGetFinalDamageParams = onGetFinalDamageParams;
    }


}
/// &lt;summary&gt;
/// buff的创建，移除，回合开始，回合结束，被攻击，攻击，被击杀，击杀等事件
/// &lt;/summary&gt;
/// &lt;param name=&quot;buff&quot;&gt;&lt;/param&gt;
public delegate void OnBuffCreate(BuffInfo buff);
public delegate void OnBuffRemove(BuffInfo buff);
public delegate void OnRoundStart(BuffInfo buff);
public delegate void OnRoundEnd(BuffInfo buff);
public delegate void BuffOnHit(BuffInfo buff, DamageInfo damageInfo, GameObject target);
public delegate void BuffOnBeHurt(BuffInfo buff, DamageInfo damageInfo, GameObject attacker);
public delegate void BuffOnRoll(BuffInfo buffInfo);
public delegate void BuffOnkill(BuffInfo buffInfo, DamageInfo damageInfo, GameObject target);
public delegate void BuffOnBeKilled(BuffInfo buffInfo, DamageInfo damageInfo, GameObject attacker);
public delegate SingleDiceObj BuffOnCast(BuffInfo buffInfo, SingleDiceObj singleDiceObj);
public delegate void OnAddBuff(BuffInfo buffInfo);
public delegate void OnGetFinalDamage(BuffInfo buffInfo,DamageInfo damageInfo);
</code></pre>
<p>可以看到基本上和猴叔的buffData定义保持一致，只不过做出了一些基于回合制的特别改动，例如回调点的改动以及一些参数描述上的的改动（待补充）</p>
<h4 id="buffinfo">BuffInfo</h4>
<p>接下来是buffInfo,buff,BuffInfo是运行时实时进行刷新的buff实例，需要注意的是，这边的buff信息的架构并没有采用猴叔的三层架构，而是只采用了两层，所以代码会有些不同，完整代码如下</p>
<pre><code class="language-c#">using System;
using System.Collections.Generic;
using UnityEngine;
[Serializable]
public class BuffInfo
{
    /// &lt;summary&gt;
    /// buff数据的模板
    /// &lt;/summary&gt;
    public BuffData buffData;
    /// &lt;summary&gt;
    /// buff是否是永久的
    /// &lt;/summary&gt;
    public bool isPermanent;
    /// &lt;summary&gt;
    /// buff的创建者
    /// &lt;/summary&gt;
    public GameObject creator = null;
    /// &lt;summary&gt;
    /// buff的目标
    /// &lt;/summary&gt;
    public GameObject target = null;
    /// &lt;summary&gt;
    /// 回合计数器
    /// &lt;/summary&gt;
    public int roundCount;
    /// &lt;summary&gt;
    /// 执行次数
    /// &lt;/summary&gt;
    public int ticked = 0;
    /// &lt;summary&gt;
    /// 当前buff的层数
    /// &lt;/summary&gt;
    public int curStack;

    public Dictionary&lt;string, object&gt; buffParam = new Dictionary&lt;string, object&gt;();


    public BuffInfo(
        BuffData buffData, GameObject creator, GameObject target, int stack = 1, bool isPermanent = false,
        Dictionary&lt;string, object&gt; buffParam = null
        )
    {
        this.buffData = buffData;
        this.creator = creator;
        this.target = target;
        this.curStack = stack;
        this.isPermanent = buffData.isPermanent;
        //this.isPermanent = buffData.isPermanent;
        this.roundCount = buffData.duringCount;
        if (buffParam != null)
        {
            foreach (var item in buffParam)
            {
                this.buffParam.Add(item.Key, item.Value);
            }
        }
    }

    public BuffInfo(
        BuffData buffData, int stack = 1, bool isPermanent = false,
        Dictionary&lt;string, object&gt; buffParam = null
        )
    {
        this.buffData = buffData;
        this.curStack = stack;
        this.isPermanent = isPermanent;
        this.roundCount = buffData.duringCount;
        if (buffParam != null)
        {
            foreach (var item in buffParam)
            {
                this.buffParam.Add(item.Key, item.Value);
            }
        }
    }
    //深拷贝
    public BuffInfo(BuffInfo buffInfo)
    {
        this.buffData =buffInfo.buffData;
        this.creator = buffInfo.creator;
        this.target = buffInfo.target;
        this.curStack = buffInfo.curStack;
        this.isPermanent = buffInfo.isPermanent;
        this.buffParam = buffInfo.buffParam;
        this.roundCount=buffInfo.roundCount;
    }
}

public enum BuffRemoveStackUpdateEnum
{
    Reduce,
    Clear,

}

public enum BuffUpdateEnum
{
    Add,
    Replace,
    Keep
}


</code></pre>
<p>BuffInfo包含了一些Runtime比较重要的信息，以及运行时的额外参数，可以看到这边为了扩展性采用了string,object的字典,关于这边的构造函数，主要还是以需求为主，有需求再往上加。</p>
<h3 id="buffhandler">BuffHandler</h3>
<p>最后是BuffHandler，Buffhandler负责管理具体游戏中角色的buff的添加和删除，以及供外部调用触发回调点函数，当然这边的回调点函数是不完全的，在有些情况下会出问题，这个在后续会讲到。</p>
<pre><code class="language-c#">public class BuffHandler : MonoBehaviour
{
    [Description(&quot;Buff列表&quot;)]
    public List&lt;BuffInfo&gt; buffList = new List&lt;BuffInfo&gt;();
    //所有判断的时候如果buff需要移除，先加入这个列表，然后再进行移除
    private List&lt;BuffInfo&gt; removeList = new List&lt;BuffInfo&gt;();

    public void AddBuff(BuffInfo buffInfo, GameObject creator)
    {
        //添加buff时候的回调点触发
        buffInfo.creator = creator;
        buffInfo.target = this.gameObject;
        HalidomManager.Instance.OnAddBuff(buffInfo);
        BuffInfo findBuffInfo = buffList.Find(x =&gt; x.buffData.id == buffInfo.buffData.id);
        if (findBuffInfo != null)//获得相同的buff的情况
        {
            if (findBuffInfo.curStack &lt; findBuffInfo.buffData.maxStack)
            {
                //findBuffInfo.curStack++;
                if (findBuffInfo.curStack + buffInfo.curStack &gt; findBuffInfo.buffData.maxStack)
                {
                    findBuffInfo.curStack = buffInfo.buffData.maxStack;
                }
                else
                {
                    findBuffInfo.curStack += buffInfo.curStack;
                }

                switch (findBuffInfo.buffData.buffUpdateEnum)
                {
                    case BuffUpdateEnum.Add:
                        findBuffInfo.roundCount += findBuffInfo.buffData.duringCount;
                        break;
                    case BuffUpdateEnum.Replace:
                        findBuffInfo.roundCount = findBuffInfo.buffData.duringCount;
                        break;
                    case BuffUpdateEnum.Keep:
                        break;
                    default:
                        break;
                }
                var charac = (Character)findBuffInfo.target.GetComponent&lt;ChaState&gt;().side;
                var index = buffList.IndexOf(findBuffInfo);
                BuffUIManager.Instance.UpdateBuffDurationTime(charac, index, findBuffInfo.curStack);
                //TODO:提示buff层数增加,根据buff的类型进行不同的处理
                findBuffInfo.buffData.onCreate?.Invoke(findBuffInfo);
            }
            else
            {
                //TODO:提示buff层数已满
            }
        }
        else
        {

            buffInfo.buffData.onCreate?.Invoke(buffInfo);
            buffList.Add(buffInfo);
            //添加buffUI
            var charac = (Character)buffInfo.target.GetComponent&lt;ChaState&gt;().side;
            BuffUIManager.Instance.CreateBuffUIObject(charac, buffInfo.buffData.id, buffInfo.curStack);
        }
    }

    /// &lt;summary&gt;
    /// 移除buff
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;buffInfo&quot;&gt;&lt;/param&gt;
    public void RemoveBuff(BuffInfo buffInfo)
    {
        switch (buffInfo.buffData.removeStackUpdateEnum)
        {
            case BuffRemoveStackUpdateEnum.Clear:
                buffInfo.buffData.onRemove?.Invoke(buffInfo);
                int index = buffList.IndexOf(buffInfo);
                var charac = (Character)buffInfo.target.GetComponent&lt;ChaState&gt;().side;
                BuffUIManager.Instance.RemoveBuffUIObject(charac, index);
                buffList.Remove(buffInfo);
                break;
            case BuffRemoveStackUpdateEnum.Reduce:
                buffInfo.curStack--;
                var charac1 = (Character)buffInfo.target.GetComponent&lt;ChaState&gt;().side;
                int index1 = buffList.IndexOf(buffInfo);
                BuffUIManager.Instance.UpdateBuffDurationTime(charac1, index1, buffInfo.curStack);
                buffInfo.buffData.onRemove?.Invoke(buffInfo);
                if (buffInfo.curStack &lt;= 0)
                {
                    int i = buffList.IndexOf(buffInfo);
                    var c = (Character)buffInfo.target.GetComponent&lt;ChaState&gt;().side;
                    BuffUIManager.Instance.RemoveBuffUIObject(c, i);
                    buffList.Remove(buffInfo);
                }
                //TODO:关于buff层数减少的刷新
                break;
            default:
                break;
        }

    }
    /// &lt;summary&gt;
    /// 每个回合开始的时候，对buff的时间进行处理,side表示当前是哪一方的回合
    /// &lt;/summary&gt;
    #region 回调点
    public void BuffRoundStartTick(int side)
    {
        if (side == 0)
        {
            for (int i = 0; i &lt; buffList.Count; i++)
            {
                if (buffList[i].buffData.tags.Contains(&quot;PlayerOnRoundStart&quot;))
                {
                    buffList[i].buffData.onRoundStart?.Invoke(buffList[i]);
                }
            }
        }
        else if (side == 1)
        {
            for (int i = 0; i &lt; buffList.Count; i++)
            {
                if (buffList[i].buffData.tags.Contains(&quot;EnemyOnRoundStart&quot;))
                {
                    buffList[i].buffData.onRoundStart?.Invoke(buffList[i]);
                }
            }
        }

    }
    //TODO:每个回合结束的时候，对buff的时间进行处理
    public void BuffRoundEndTick(int side)
    {
        List&lt;BuffInfo&gt; removeList = new List&lt;BuffInfo&gt;();
        //因为buffhandler既不知道是给谁挂载的，也不知道是什么回合，所以需要两个参数来判断
        //传入的是玩家并且当前是玩家的回合
        if (side == 0 &amp;&amp; BattleManager.Instance.GetCurrentState() == BattleManager.Instance.GetStates()[GameState.PlayerRoundEndResolution])
        {

            //触发玩家身上的有OnMyTurnEnd的buff
            foreach (var buff in buffList)
            {
                if (buff.buffData.tags.Contains(&quot;OnMyTurnEnd&quot;))
                {
                    buff.buffData.onRoundEnd?.Invoke(buff);
                }

            }

            for (int i = 0; i &lt; buffList.Count; i++)
            {
                if (buffList[i].buffData.tags.Contains(&quot;OnMyTurnEnd&quot;))
                {
                    if (buffList[i].isPermanent == false)//非永久buff
                    {
                        buffList[i].roundCount--;

                        buffList[i].roundCount = Mathf.Max(0, buffList[i].roundCount);//可能出现负数的情况
                        if (buffList[i].roundCount == 0)
                        {
                            removeList.Add(buffList[i]);
                        }
                    }
                }

            }
            for (int i = 0; i &lt; removeList.Count; i++)
            {
                RemoveBuff(removeList[i]);
            }
        }
        //传入的是敌人 在玩家的回合结束
        else if (side == 1 &amp;&amp; BattleManager.Instance.GetCurrentState() == BattleManager.Instance.GetStates()[GameState.PlayerRoundEndResolution])
        {
            Debug.Log(&quot;传入的是敌人 在玩家的回合结束&quot;);
            foreach (var buff in buffList)
            {
                if (buff.buffData.tags.Contains(&quot;OnOtherTurnEnd&quot;))
                {
                    buff.buffData.onRoundEnd?.Invoke(buff);
                }

            }

            for (int i = 0; i &lt; buffList.Count; i++)
            {
                if (buffList[i].buffData.tags.Contains(&quot;OnOtherTurnEnd&quot;))
                {
                    if (buffList[i].isPermanent == false)//非永久buff
                    {
                        buffList[i].roundCount--;

                        buffList[i].roundCount = Mathf.Max(0, buffList[i].roundCount);//可能出现负数的情况
                        if (buffList[i].roundCount == 0)
                        {
                            removeList.Add(buffList[i]);
                        }
                    }
                }

            }
            for (int i = 0; i &lt; removeList.Count; i++)
            {
                RemoveBuff(removeList[i]);
            }
        }
        //传入的是玩家 在敌人的回合结束
        else if (side == 0 &amp;&amp; BattleManager.Instance.GetCurrentState() == BattleManager.Instance.GetStates()[GameState.EnemyRoundEndResolution])
        {
            Debug.Log(&quot;传入的是玩家 在敌人的回合结束&quot;);
            foreach (var buff in buffList)
            {
                if (buff.buffData.tags.Contains(&quot;OnOtherTurnEnd&quot;))
                {
                    buff.buffData.onRoundEnd?.Invoke(buff);
                }

            }

            for (int i = 0; i &lt; buffList.Count; i++)
            {
                if (buffList[i].buffData.tags.Contains(&quot;OnOtherTurnEnd&quot;))
                {
                    if (buffList[i].isPermanent == false)//非永久buff
                    {
                        buffList[i].roundCount--;

                        buffList[i].roundCount = Mathf.Max(0, buffList[i].roundCount);//可能出现负数的情况
                        if (buffList[i].roundCount == 0)
                        {
                            removeList.Add(buffList[i]);
                        }
                    }
                }

            }
            for (int i = 0; i &lt; removeList.Count; i++)
            {
                RemoveBuff(removeList[i]);
            }
        }

        //传入的是敌人 在敌人的回合结束
        if (side == 1 &amp;&amp; BattleManager.Instance.GetCurrentState() == BattleManager.Instance.GetStates()[GameState.EnemyRoundEndResolution])
        {
            Debug.Log(&quot;传入的是敌人 在敌人的回合结束&quot;);
            //触发敌人身上的有OnMyTurnEnd的buff
            foreach (var buff in buffList)
            {
                if (buff.buffData.tags.Contains(&quot;OnMyTurnEnd&quot;))
                {
                    buff.buffData.onRoundEnd?.Invoke(buff);
                }

            }

            for (int i = 0; i &lt; buffList.Count; i++)
            {
                if (buffList[i].buffData.tags.Contains(&quot;OnMyTurnEnd&quot;))
                {
                    if (buffList[i].isPermanent == false)//非永久buff
                    {
                        buffList[i].roundCount--;

                        buffList[i].roundCount = Mathf.Max(0, buffList[i].roundCount);//可能出现负数的情况
                        if (buffList[i].roundCount == 0)
                        {
                            removeList.Add(buffList[i]);
                        }
                    }
                }

            }
            for (int i = 0; i &lt; removeList.Count; i++)
            {
                RemoveBuff(removeList[i]);
            }
        }
    }

    public void BuffOnReRoll()
    {
        for (int i = 0; i &lt; buffList.Count; i++)
        {
            buffList[i].buffData.onRoll?.Invoke(buffList[i]);
        }
    }
    //待定
    public void BuffOnCast()
    {
        foreach (var buff in buffList)
        {

        }
    }
    #endregion
    public void RecheckBuff(ChaProperty[] buffProp, ref ChaControlState chaControlState)
    {

        foreach (var buff in buffList)
        {
            buffProp[0] += buff.buffData.propMod[0] * buff.curStack;
            buffProp[1] += buff.buffData.propMod[1];
            chaControlState += buff.buffData.stateMod;
        }
    }
}
</code></pre>
<h3 id="_2">使用：</h3>
<p>每一个收到buff影响的character身上都挂了一个buffHandler，其他的相关manager在合适的时候调用回调点触发函数，例如在受伤时的回调函数和攻击时的回调函数，就在damageManager中触发（关于damage的详细信息，见猴与花果山的文章）</p>
<h3 id="_3">引擎内配置：</h3>
<p><img alt="image-20240529225508974" src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/image-20240529225508974.png" /></p>
<p>这是一个最简单buffSO的截图示例，采取了SO配置整体信息+脚本内配置回调点具体函数，在运行的时候初始化为buffData，由于一些原因，损失了每个回调点的参数，也无法进行回调点的组合和公用，因此只能说是堪堪能用。</p>
<p>大体的工作流如下：</p>
<p>先在写回调点event的脚本里写相应的buff的回调点函数，再手动加进相应的字典里，字典的key是回调点函数效果的枚举，因此也需要对对应相关回调点的enum进行修改，再将buffName添加进buffName的enum（其实名字直接用string也可以，因为配置步骤过多，所以enum不容易错），之后再在需要用到buffData的地方，从buffData的字典里找出相应的buffData,根据具体的情况生成buffInfo，加到具体角色身上的buffHandler的bufflist里</p>
<h2 id="buff_2">新buff系统：</h2>
<h3 id="buff_3">旧buff系统的问题：</h3>
<p>从上述的描述中，其实已经可以看出，先前的buff系统在各个方面都存在不少的问题，但是这边还是要具体列举一下开发中遇到的问题。</p>
<p>1、配置上的问题，配置的步骤太过繁琐导致容易出错，随着业务需求的增加，会很繁琐，也就是程序化的程度不够，需要指定一套相对比较完善的配置流程</p>
<p>2、对于结构上的问题，每一个回调点：例如受击方扣除x点血量这种event，应该是可以公用的，因此需要决定参数开放在哪的问题，但是旧buff系统关于这一块没有很好地解决</p>
<p>3、与UI的交互的问题，应该统一规定好与UI交互的位置，在移除buff图标的时候，不需要手动地调用一些方法</p>
<h3 id="buff_4">新buff系统组成：</h3>
<p>首先是配置，配置方面采用luban配表游戏内so中间层显示的模式，,大体的数据结构不变。</p>
<h3 id="buff_5">新buff系统系统拆解：</h3>
<h4 id="_4">层次结构：</h4>
<p>主要分为luban层，SO层，和其他具体runtime时的数据层，配置的部分主要在luban层和SO层</p>
<h4 id="luban">luban层配置</h4>
<p>在luban的配置层，主要完成的工作是进行buffData的配置,也就是需要在excel表格中进行buffData的配置，在excel中需要进行如下配置</p>
<table>
<thead>
<tr>
<th>##var</th>
<th>id</th>
<th>name</th>
<th>buffIcon</th>
<th>tags</th>
<th>maxStack</th>
<th>buffRemoveStackUpdateEnum</th>
<th>buffUpdateEnum</th>
<th>duringCount</th>
<th>isPermanent</th>
<th>onCreateEvents</th>
<th>onRemoveEvents</th>
<th>onOtherRoundStartEvents</th>
<th>onThisRoundStartEvents</th>
<th>onOtherRoundEndEvents</th>
<th>onThisRoundEndEvents</th>
<th>onHitEvents</th>
<th>onBeHurtEvents</th>
<th>onKillEvents</th>
<th>onBeKilledEvents</th>
</tr>
</thead>
<tbody>
<tr>
<td>##Type</td>
<td>string</td>
<td>string</td>
<td>string</td>
<td>(list#sep=|),string</td>
<td>int</td>
<td>BuffRemoveStackUpdateEnum</td>
<td>BuffUpdateEnum</td>
<td>int</td>
<td>bool</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
<td>(list#sep=|),string</td>
</tr>
<tr>
<td>##</td>
<td>buff的唯一id</td>
<td>buff的名字</td>
<td>路径</td>
<td>buff的tag</td>
<td>buff的上限层数</td>
<td>buff移除的时候的模式</td>
<td>buff添加的模式</td>
<td>buff持续的回合数</td>
<td>是否永久</td>
<td>创建触发事件的类名列表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>测试buff</td>
<td>""</td>
<td></td>
<td>5</td>
<td>0</td>
<td>0</td>
<td>4</td>
<td>TRUE</td>
<td>HpEnhanceEvent</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>可以看到基本上在excel里面的配置就是之前buffData的部分配置，值得一提的是，这边的回调点配置是一个string的list,这边记录的是event的名字，每个event都是一个类，这边在具体生成的时候会反射转换成类</p>
<h4 id="unityso">unitySO层配置</h4>
<p>在unitySO层的配置，主要时配置一些excel中配置不了的回调点event的参数，例如我有一个event指代的是扣血，不需要为了每个buff专门写每个的扣血event,因此需要开放出变量进行配置工作（下图是一个例子）</p>
<p><img alt="image-20240612224648289" src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/image-20240612224648289.png" /></p>
<h4 id="_5">具体工作流程：</h4>
<p>1、先在excel表中配置buffData的一部分数据，通过luban的脚本生成json到unity的asset下（具体生成到什么文件夹看个人喜好）</p>
<p>2、在unity中通过buffEditor生成出buffDataSO以及相应的event</p>
<p>3、buffDataSO就是原本的buffData，需要再在实际运行的时候转成buffInfo</p>
<p>在引擎中生成出来的时候，会在指定的路径生成出相应buff的一整个文件夹，图示如下：</p>
<p><img alt="image-20240612230816691" src="https://typorapicturefivuvuv.oss-cn-shanghai.aliyuncs.com/picgo/image-20240612230816691.png" /></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
